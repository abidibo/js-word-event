{"mappings":"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","sources":["src/js-word-event.js"],"sourcesContent":["\"use strict\";\n\n/**\n * WordEvent class\n * @classdesc <p>The class allows to listen to typed words events.</p>\n *            <p>A word is considered to be a set of characters typed within a time interval between each other defined thorugh options.</p>\n *            <p>It is possible to set a dictionary of words and regular expressions with callback functions to be called when the word typed matches a dictionary word or rexp.</p>\n */\nexport class WordEvent {\n    /**\n     * WordEvent constructor\n     *\n     * @constructs WordEvent\n     * @param {Object} options - the class options object:\n     * @param {String|Element} [options.target=document] - the element to which attach the keyboard event\n     * @param {Integer} [options.digitInterval=500] - time interval (ms) used to consider characters belonging to the same word\n     * @param {String} [options.eventType='keyup'] - the keyboard event type\n     * @param {Function} [options.acceptedCode] - the function used to check if a typed char can be accepted and so can form part of the word or not, by default all alpha-numerical characters are accepted [a-z0-9]. The function is invoked passing the parameter evt which is the event object, and must return true if it is accepted, false otherwise.\n     * @example\n     *    var we = new WordEvent({digitInterval: 400, acceptedCode: function(evt) {return (evt.keyCode>47 && evt.keyCode<58) : false; // only numbers}});\n     */\n    constructor (options = {}) {\n        this.target = options.target || document;\n        this.digitInterval = options.digitInterval || 500;\n        this.eventType = options.eventType || 'keyup';\n        this.acceptedCode = options.acceptedCode || function (evt) { return ((evt.keyCode > 47 && evt.keyCode < 58) || (evt.keyCode > 64 && evt.keyCode < 91)) || false; };\n        this.dictionary = { string: [], rexp: [] };\n    }\n\n    /**\n     * Adds the given words and callbacks to the dictionary, parameters can be a pair of word and callback or two arrays of words and callbacks (tied through indexes)\n     *\n     * @param {String|Array} words - words to add to the dictionary, a single word can be a string or a regular expression\n     * @param {Function|Array} callbacks - callbacks to call when the word event is fired. The callbacks are binded to the target element and are passed the array of event objects which generated the word.\n     * @return {void}\n     */\n    listen (words, callbacks) {\n        words = words instanceof Array ? words : [words];\n        callbacks = callbacks instanceof Array ? callbacks : [callbacks];\n\n        for(let i = 0, l = words.length; i < l; i++) {\n            if(words[i] instanceof RegExp) {\n                this.dictionary.rexp[words[i]] = callbacks[i];\n            }\n            else {\n                this.dictionary.string[words[i]] = callbacks[i];\n            }\n        }\n    }\n\n    /**\n     * Removes the the given words from the dictionary. Parameter can be a single word or an array of words.\n     *\n     * @param {String|Array} words - words to remove from dictionary\n     * @return {void}\n     */\n    unlisten (words) {\n        words = words instanceof Array ? words : [words];\n        for(let i = 0, l = words.length; i < l; i++) {\n            delete this.dictionary[words[i] instanceof RegExp ? 'rexp' : 'string'][words[i]];\n        }\n    }\n\n    /**\n     * Class activation, the class starts listening to typed words\n     *\n     * @return {void}\n     */\n    activate () {\n        const self = this;\n        // closure to construct the word\n        let word = '';\n        let events = [];\n        let lastTime = null;\n        let wordCtrl = {\n            checkTime: function() {\n                var time = new Date().getTime();\n                var result = (lastTime === null || time - lastTime <= self.digitInterval) || false;\n                lastTime = time;\n                return result;\n            },\n            append: function(evt) {\n                if(self.acceptedCode(evt)) {\n                    word += evt.key;\n                    events.push(evt);\n                }\n            },\n            read: function() {\n                return word;\n            },\n            events: function() {\n                return events;\n            },\n            reset: function() {\n                word = '';\n                events = [];\n            }\n        };\n        this.target.addEventListener(this.eventType, this.elistener = function (evt) { self.eventListener(evt, wordCtrl); });\n    }\n\n    /**\n     * Class deactivation, the class stops listening to typed words\n     *\n     * @return {void}\n     */\n    deactivate () {\n        this.target.removeEventListener(this.eventType, this.elistener);\n    }\n\n    /**\n     * Method called every time the eventType is fired\n     *\n     * @description Sets a timeout to dispatch the word event, such timeout is cleared if the next character is typed before the end of digit_interval milliseconds.\n     * @param {Event} evt - the fired event\n     * @param {Object} wordCtrl - the wordCtrl instance\n     * @return {void}\n     */\n    eventListener (evt, wordCtrl) {\n        if(wordCtrl.checkTime()) {\n            clearTimeout(this.to);\n            wordCtrl.append(evt);\n        } else {\n            wordCtrl.reset();\n            wordCtrl.append(evt);\n        }\n        this.to = setTimeout(this.dispatch.bind(this, wordCtrl), this.digitInterval);\n    }\n\n    /**\n     * Executes the callback for the typed word if it is included in the dictionary\n     *\n     * @param {Object} wordCtrl - the wordCtrl instance\n     * @return {void}\n     */\n    dispatch (wordCtrl) {\n        const callback = this.find(wordCtrl.read());\n        if(callback) {\n            callback.call(this.target, wordCtrl.events(), wordCtrl.read());\n        }\n    }\n\n    /**\n     * Checks if the typed word belongs to dictionary, and in that case return its callback.\n     * First it checks strings then regular expressions.\n     *\n     * @param {String} word - the typed word\n     * @return {Function} matching callback function or null\n     */\n    find (word) {\n        // strings\n        if(typeof this.dictionary.string[word] !== 'undefined') {\n            return this.dictionary.string[word];\n        }\n\n        // regexp\n        for(let key in this.dictionary.rexp) {\n            if(this.dictionary.rexp.hasOwnProperty(key)) {\n                var rexp = new RegExp(key.substring(1, key.length - 1));\n                if(rexp.test(word)) {\n                    return this.dictionary.rexp[key];\n                }\n            }\n        }\n\n        return null;\n    }\n}\n\nwindow.WordEvent = WordEvent\n"],"names":[],"version":3,"file":"js-word-event.module.mjs.map"}